/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
var __webpack_exports__ = {};

;// CONCATENATED MODULE: ./node_modules/@rowi/rowi-element/rowi-element.js
class RowiElement extends HTMLElement {
    #attrs = {}
    #initialValues = {}
    #initialValuesStarted = false
    #handlers = {}
    #allowedTypes = new Set(['number', 'integer', 'string', 'boolean'])

    #refs = {}
    get $() { return this.#refs }

    constructor() {
        super()
        let props = this.props || {}
        Object.defineProperties(this, Object.entries(props).reduce(
            (accum, [key, prop]) => {
                let attr = prop.attr || this.#getDefaulAttr(key)
                this.#attrs[attr] = {name: key, prop}
                if (prop.handler != null) {
                    this.#handlers[key] = ev => prop.handler.apply(this, [ev.detail])
                    this.addEventListener('$' + key, this.#handlers[key])
                }
                if (this.hasOwnProperty(key))
                    this.#initialValues[key] = this[key]
                else if (prop.type === 'boolean' && this.getAttribute(attr) == null && prop.default) {
                    this.#initialValues[key] = true
                }
                accum[key] = {
                    get: () => {
                        this.#setInitialValues()
                        let v = this.getAttribute(attr)
                        return (v == null || v === "") && prop.type !== 'boolean'
                            ? prop.default : this.#attrToProp(v, prop.type)
                    },
                    set: (v) => {
                        this.#setInitialValues(key)
                        if (prop.type === 'boolean') {
                            if (v) this.setAttribute(attr, '')
                            else this.removeAttribute(attr)
                        } else {
                            this.setAttribute(attr, v)
                        }
                    }
                }
                return accum
            }, {}
        ))
    }

    #setInitialValues(propSetting) {
        if (this.#initialValuesStarted) return
        this.#initialValuesStarted = true
        for (let key in this.#initialValues) {
            if (key === propSetting) continue
            this[key] = this.#initialValues[key]
        }
    }

    #getDefaulAttr(prop) {
        return 'data-' + prop.replaceAll(/[A-Z]/g, l => `-${l.toLowerCase()}`)
    }

    $checkType(value, type) {
        return (
            (type == 'integer' && Number.isInteger(value))
            || (
                ['string', 'boolean', 'number', 'object'].includes(type)
                && typeof value === type
            )
            || (type == 'array' && Array.isArray(value))
        )
    }

    #checkType(name, value, type) {
        if (!this.#allowedTypes.has(type)) {
            throw new TypeError(
                `Allowed types are "${this.#allowedTypes}". Type given: ${type}`
            )
        }
        if (!this.$checkType(value, type))
            throw new TypeError(
                `Type of "${name}" is ${type}. Value given: ${value}`
            )
    }


    #attrToProp(value, type) {
        if (type === 'number' || type === 'integer') return Number(value)
        else if (type === 'boolean') return value != null
        else return value
    }

    connectedCallback() { this.#setInitialValues() }

    attributeChangedCallback(name, oldValue, newValue) {
        let attrElement = this.#attrs[name]
        let propName = attrElement.name, prop = attrElement.prop

        let initialValuesStarted = this.#initialValuesStarted
        this.#setInitialValues()
        if (!initialValuesStarted && propName in this.#initialValues)
            return

        if (oldValue !== newValue) {
            if (propName == null) return
            let propValue = this.#attrToProp(newValue, prop.type)
            if (prop.type != 'boolean') {
                try {
                    this.#checkType(propName, propValue, prop.type)
                    if (prop.validator) {
                        const valid = prop.validator.apply(this, [propValue])
                        if (!valid)
                            throw `Prop "${name}" value ${value} is not valid`
                    }
                } catch (error) {
                    console.error(error)
                    if (oldValue == null) this.removeAttribute(attrName)
                    else this.setAttribute(attrName, oldValue)
                    return
                }
            }

            const oldPropValue = this.#attrToProp(oldValue, prop.type)
            this.dispatchEvent(new CustomEvent('$' + propName,
                {detail: {oldValue: oldPropValue, newValue: propValue}}
            ))
        }
    }

    $set(propName, value, safe = true) {
        if (safe && this.#handlers[propName] != null)
            this.removeEventListener('$' + key, this.#handlers[propName])
        this[propName] = value
        if (safe && this.#handlers[propName] != null)
            this.addEventListener('$' + key, this.#handlers[propName])
    }

    #createElementHelper(tag, opts, children, refs) {
        const {id, on, attrs, name, props} = opts
        const elem_ = typeof tag === 'string' ? document.createElement(tag) : tag

        if (opts.class != null) elem_.className = opts.class
        if (id != null) elem_.id = id
        if (name != null ) refs[name] = elem_

        for (const event in on || {}) {
            elem_.addEventListener(event, on[event])
        }

        if (typeof children  === 'string') children = [children]
        for (const child of children) {
            if (typeof child  === 'string')
                elem_.appendChild(document.createTextNode(child))
            else if (Array.isArray(child)) {
                elem_.appendChild(this.$createElement(child, refs))
            }
        }

        for (const attr in attrs || {}) {
            elem_.setAttribute(attr, attrs[attr])
        }
        for (const prop in props) {
            elem_[prop] = props[prop]
        }
        return elem_
    }

    $createElement(elem, refs) {
        refs = refs || {}
        let tag = 'div'
        let opts = {}
        let children = elem
        if (
            elem[0] instanceof Element || elem[0] instanceof DocumentFragment
            || typeof elem[0] === 'string'
        ) {
            tag = elem[0]
            children = children.slice(1)
        }
        if (
            typeof elem[1] === 'object' && elem[1] != null
            && !Array.isArray(elem[1])
        ) {
            opts = elem[1]
            children = children.slice(1)
        }
        return this.#createElementHelper(tag, opts, children, refs)
    }

    $buildShadow(content) {
        this.attachShadow({mode: 'open'})
        this.$createElement([this.shadowRoot, ...content], this.#refs)
    }
}

;// CONCATENATED MODULE: ./node_modules/@rowi/rowi-overlay/rowi-overlay.js



class RWOverlay extends RowiElement {
  #connected = false
  #overlay
  #content
  #overlayClicked
  constructor () {
    super()
    this.#overlay = document.createElement('div')
    this.#overlay.style.cssText = `
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      z-index: 2147483647;
      background-color: rgba(${this.props.color.default}, 0);
      transition: background-color ${this.props.transition.default}ms;
    `
    if (this.intangible) this.#overlay.style.pointerEvents = 'none'
    this.#overlayClicked = this.#_overlayClicked.bind(this)
  }

  connectedCallback () {
    this.style.display = 'none'
    this.#connected = true 
  }
  disconnectedCallback () { this.#connected = false }

  static get observedAttributes () {
    return [
      'data-opened',
      'data-opacity',
      'data-color',
      'data-transition',
      'data-persistent',
      'data-intangible',
    ]
  }

  get props () {
    return {  
      opened: { type: 'boolean', handler () { this.#stateChanged() } },
      opacity: { type: 'number', default: 0 },
      color: { type: 'string', default: '0,0,0' },
      transition: {
        type: 'number', default: 300,
        handler ({newValue}) {
          this.#overlay.style.transition = `background-color ${newValue}ms`
        }
      },
      persistent: { type: 'boolean' },
      intangible: {
        type: 'boolean',
        handler ({newValue}) {
          this.#overlay.style.pointerEvents = newValue ? 'none' : null
        }
      },
    }
  }

  #_overlayClicked (ev) {
    if (ev.target === this.#overlay || !this.#overlay.contains(ev.target)) {
      this.opened = false
      ev.stopPropagation()
    }
  }

  #stateChanged () {
    if (!this.#connected) return
    if (this.opened) {
      if (this.children.length === 0) return
      this.#content = this.children[0]
      if (this.intangible && this.#content.style.pointerEvents === '') {
        this.#content.style.pointerEvents = 'auto'
      }
      if (!this.persistent) {
        document.addEventListener('click', this.#overlayClicked)
      }
      this.#overlay.append(this.#content)
      document.body.append(this.#overlay)
      setTimeout(() => {
        this.#overlay.style.backgroundColor = `rgba(${this.color}, ${this.opacity})`
      })
    } else {
      if (!this.persistent) {
        document.removeEventListener('click', this.#overlayClicked)
      }
      this.#overlay.style.backgroundColor = `rgba(${this.color}, 0)`
      setTimeout(() => {
        this.append(this.#content)
        document.body.removeChild(this.#overlay)
      }, this.transition)
    }
  }
}

customElements.define("rw-overlay", RWOverlay)

;// CONCATENATED MODULE: ./rowi-dropdown.js




function getBoxInfo(maxWidth, maxHeight, style) {
  style.maxWidth = maxWidth
  style.maxHeight = maxHeight
  return style
}

class RWDropdown extends RowiElement {
  #connected
  #windowResized
  constructor () {
    super()
    this.#connected = false

    const defaultTransition = this.props.transitionTime.default

    const style = `
      .dropdown {
        background-color: var(--rw-dropdown-color, white);
        border-radius: var(--rw-dropdown-radius, 4px);
        position: absolute;
        filter: var(--rw-dropdown-filter, drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.35)));
        border: var(--rw-dropdown-border, none);
        opacity: 0;
        transform: scale(0);
        transition: opacity ${defaultTransition}ms, transform ${defaultTransition}ms;
      }

      .dropdown.opened {
        opacity: 1;
        transform: scale(1);
        transition: opacity ${defaultTransition}ms, transform ${defaultTransition}ms;
      } 

      .arrow {
        border: 1px solid var(--rw-dropdown-color, white);
        position: absolute;
        width: 0;
        height: 0;
      }`

    this.$buildShadow([
      ['style', {props: {textContent: style}}],
      ['slot', {name: 'holder', attrs: {name: 'holder'}}],
      ['rw-overlay', {
        name: 'dropdown',
        // props: {
        //   opacity: this.props.opacity.default,
        //   color: this.props.overlayColor.default,
        //   transition: this.props.transitionTime.default
        // },
        // on: {
        //   $opened: ev => {
        //     this._avoidUpdateOverlay = true
        //     this.opened = ev.detail.newValue
        //   }
        // }
      },
        ['div', {name: 'box', class: 'dropdown'},
          ['div', {name: 'arrow', class: 'arrow'}],
          ['slot', {attrs: {name: 'dropdown'}}]
        ]
      ]
    ])

    this.#windowResized = this.#_windowResized.bind(this)
  }

  connectedCallback () { this.#connected = true }
  disconnectedCallback () { this.#connected = false }

  static get observedAttributes () { return [
    'data-opened',
    'data-opacity',
    'data-overlay-color',
    'data-transition-time',
    'data-persistent',
    'data-intangible',
    'data-dropdown-style',
    'data-dropdown-position',
  ]}

  get props () {
    this._possibleDropdowns = ['normal', 'center', 'fit', 'corner']
    this._centralPositions = ['top', 'bottom', 'left', 'right']
    this._numericProps = [
      ...this._centralPositions, 'maxWidth', 'maxHeight', 'width', 'height'
    ]
    this._cornerPositions = [
      'top_left', 'top_right', 'bottom_left', 'bottom_right'
    ]
    this._possiblePositions = this._centralPositions.concat(this._cornerPositions)
    this._positions = new Set(this._possiblePositions)

    this._avoidUpdateOverlay = false

    return {  
      opened: { type: 'boolean', handler () {
        this._openedChanged()
      }},
      opacity: { type: 'number', default: 0, handler ({newValue}) {
        this.$.dropdown.opacity = newValue
      }},
      overlayColor: { type: 'string', default: '0,0,0', handler ({newValue}) {
        this.$.dropdown.color = newValue
      }},
      transitionTime: { type: 'number', default: 300, handler ({newValue}) {
        this.$.dropdown.transition = newValue
      }},
      persistent: { type: 'boolean', handler ({newValue}) {
        this.$.dropdown.persistent = newValue
      }},
      intangible: { type: 'boolean', handler ({newValue}) {
        this.$.dropdown.intangible = newValue
      }},
      dropdownStyle: { type: 'string', default: 'normal',
        validator (value) {
          return this._possibleDropdowns.includes(value)
        }
      },
      dropdownPosition: { type: 'string', default: 'all',
        validator (valuesString) {
          valuesString = valuesString.trim()
          if (valuesString === 'all') return true
          const values = valuesString.split(/ +/)
          for (const value of values) {
            if (!this._possiblePositions.includes(value)) return false
          }
          return true
        },
        handler ({newValue}) {
          newValue = newValue.trim()
          if (newValue === 'all') {
            this._positions = new Set(this._possiblePositions)
          } else {
            this._positions = new Set(newValue.trim().split(/ +/))
          }
        }
      }
    }
  }

  _compareBoxes (boxes, positions) {
    for (const position of positions) {
      if (! boxes.hasOwnProperty(position)) continue
      const style = boxes[position]
      if (style.maxWidth * style.maxHeight > this._largestSize) {
        this._largestBoxPosition = position
        this._largestBoxStyle = style
      }
    }
  }  

  _findLargestBox (rect) {
    const _window = document.documentElement
    const windowHeight = _window.clientHeight
    const windowWidth = _window.clientWidth
  
    const rightWidth = windowWidth - rect.right
    const bottomHeight = windowHeight - rect.bottom
    const invertedLeft = windowWidth - rect.x
    const invertedBottom = windowHeight - rect.y

    this._largestSize = -Infinity
  
    if (this.dropdownStyle === 'normal') {
      const boxes = {
        top_left: getBoxInfo(
          rect.right, rect.y, {right: rect.right, bottom: rect.y}
        ),
        top_right: getBoxInfo(
          invertedLeft, rect.y, {left: rect.x, bottom: rect.y}
        ),
        left_top: getBoxInfo(
          rect.x, rect.bottom, {right: rect.x, bottom: rect.bottom}
        ),
        left_bottom: getBoxInfo(
          rect.x, invertedBottom, {right: rect.x, top: rect.y}
        ),
        right_top: getBoxInfo(
          rightWidth, rect.bottom, {left: rect.right, bottom: rect.bottom}
        ),
        right_bottom: getBoxInfo(
          rightWidth, invertedBottom, {left: rect.right, top: rect.y}
        ),
        bottom_left: getBoxInfo(
          rect.right, bottomHeight, {right: rect.right, top: rect.bottom}
        ),
        bottom_right: getBoxInfo(
          invertedLeft, bottomHeight, {left: rect.x, top: rect.bottom}
        ),
      }
      for (let position of this._positions) {
        if (['top', 'bottom'].includes(position)) {
          this._compareBoxes(boxes, [position + '_left', position + '_right'])
        } else {
          this._compareBoxes(boxes, [position + '_top', position + '_bottom'])
        }
      }
    } else {
      const centerVerticalStyle = {transform: 'translateX(-50%)', left: rect.x}
      const centerHorizStyle = {transform: 'translateY(-50%)', top: rect.y}
      const fitVerticalStyle = {left: rect.x, width: rect.width}
      const fitHorizStyle = {top: rect.y, height: rect.height}
      const boxes = {
        center: {
          top: getBoxInfo(windowWidth , rect.y, centerVerticalStyle),
          left: getBoxInfo(rect.x , windowHeight, centerHorizStyle),
          right: getBoxInfo(rightWidth , windowHeight, centerHorizStyle),
          bottom: getBoxInfo(windowWidth , bottomHeight, centerVerticalStyle),
        },
        fit: {
          top: getBoxInfo(
            rect.width , rect.y, {bottom: rect.y, ...fitVerticalStyle}
          ),
          left: getBoxInfo(
            rect.x , rect.height, {right: rect.x, ...fitHorizStyle}
          ),
          right: getBoxInfo(
            rightWidth , rect.height, {left: rect.right, ...fitHorizStyle}
          ),
          bottom: getBoxInfo(
            rect.width , bottomHeight, {top: rect.bottom, ...fitVerticalStyle}
          ),
        },
        corner: {
          top_left: getBoxInfo(
            rect.x , rect.y, {right: rect.x, bottom: rect.y}
          ),
          top_right: getBoxInfo(
            rightWidth , rect.y, {left: rect.right, bottom: rect.y}
          ),
          bottom_left: getBoxInfo(
            rect.x , bottomHeight, {right: rect.x, top: rect.bottom}
          ),
          bottom_right: getBoxInfo(
            rightWidth , bottomHeight, {left: rect.right, top: rect.bottom}
          ),
        }
      }
      this._compareBoxes(boxes[this.dropdownStyle], this._positions)
    }
  }

  _openedChanged () {
    if (this.opened) {
      window.addEventListener('resize', this.#windowResized)
      this._updateAll()
      if (!this._avoidUpdateOverlay) {
        this.$.dropdown.opened = true
        this._avoidUpdateOverlay = false
      }
      setTimeout(() => this.$.box.classList.add('opened'))
    } else {
      window.removeEventListener('resize', this.#windowResized)
      if (!this._avoidUpdateOverlay) {
        this.$.dropdown.opened = false
        this._avoidUpdateOverlay = false
      }
      setTimeout(() => this.$.box.classList.remove('opened'))
    }
  }

  #_windowResized () {
    clearTimeout(this._windowResizedTimeoutID)
    this._windowResizedTimeoutID = setTimeout(() => this._updateAll(), 200)
  }

  _applyBoxStyle (style) {
    Object.entries(style).forEach(([prop, value]) => {
      if (this._numericProps.includes(prop)) value += 'px'
      this.$.box.style[prop] = value
    })
  }

  _updateAll () {
    const holder = this.$.holder
    const holderRect = holder.getBoundingClientRect()
    this._findLargestBox(holderRect)
    this._applyBoxStyle(this._largestBoxStyle)
    this._updateDropdown(holderRect)
  }

  _centerBoxHelper1 (boxSize, midPoint, windowSize, style, sides) {
    if (midPoint < windowSize / 2) {
      this._centerBoxHelper2(boxSize, midPoint, style, sides[0])
    } else {
      this._centerBoxHelper2(boxSize, windowSize - midPoint, style, sides[1])
    }
  }

  _centerBoxHelper2 (boxSize, halfSize, style, side) {
    if (boxSize/2 < halfSize) {
      this._applyBoxStyle(this._largestBoxStyle)
    } else {
      style[side] = 0
      this._applyBoxStyle(style)
    }
  }
  _updateDropdown (rect) {
    if (this.dropdownStyle !== 'center') return

    const box = this.$.box
    const dropdown = this.$.dropdown
    const opened = dropdown.opened

    if (!opened) {
      box.style.visibility = 'hidden'
      body.append(box)
    }
    const width = box.clientWidth
    const height = box.clientHeight
    if (!opened) {
      dropdown.append(box)
      box.style.visibility = 'visible'
    }

    const style = Object.assign({}, this._largestBoxStyle)
    delete style.transform

    const _window = document.documentElement
    if (['bottom', 'top'].includes(this._largestBoxPosition)) {
      const midPoint = rect.x + rect.width / 2
      this._centerBoxHelper1(
        width, midPoint, _window.clientWidth, style, ['left', 'right']
      )
    } else {
      const midPoint = rect.y + rect.height / 2
      this._centerBoxHelper1(
        height, midPoint, _window.clientHeight, style, ['top', 'bottom']
      )
    }
  }
}

customElements.define("rw-dropdown", RWDropdown)
/******/ })()
;